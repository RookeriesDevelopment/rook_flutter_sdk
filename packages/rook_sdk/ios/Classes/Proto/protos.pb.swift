// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: protos.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum HealthPermissionProto: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case sleep // = 0
  case physical // = 1
  case body // = 2
  case all // = 3
  case UNRECOGNIZED(Int)

  init() {
    self = .sleep
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .sleep
    case 1: self = .physical
    case 2: self = .body
    case 3: self = .all
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .sleep: return 0
    case .physical: return 1
    case .body: return 2
    case .all: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension HealthPermissionProto: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [HealthPermissionProto] = [
    .sleep,
    .physical,
    .body,
    .all,
  ]
}

#endif  // swift(>=4.2)

enum AvailabilityStatusProto: SwiftProtobuf.Enum {
  typealias RawValue = Int
  case installed // = 0
  case notInstalled // = 1
  case notSupported // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .installed
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .installed
    case 1: self = .notInstalled
    case 2: self = .notSupported
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .installed: return 0
    case .notInstalled: return 1
    case .notSupported: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension AvailabilityStatusProto: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [AvailabilityStatusProto] = [
    .installed,
    .notInstalled,
    .notSupported,
  ]
}

#endif  // swift(>=4.2)

struct DeviceNotSupportedExceptionProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct HealthConnectNotInstalledExceptionProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct HttpRequestExceptionProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var code: UInt32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct MissingConfigurationExceptionProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct MissingPermissionsExceptionProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct RequestQuotaExceededExceptionProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct SDKNotInitializedExceptionProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct TimeoutExceptionProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct UserNotInitializedExceptionProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct GenericExceptionProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct MissingAndroidPermissionsExceptionProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var message: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct ResultBooleanProto {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var result: ResultBooleanProto.OneOf_Result? = nil

  var success: Bool {
    get {
      if case .success(let v)? = result {return v}
      return false
    }
    set {result = .success(newValue)}
  }

  var deviceNotSupportedExceptionProto: DeviceNotSupportedExceptionProto {
    get {
      if case .deviceNotSupportedExceptionProto(let v)? = result {return v}
      return DeviceNotSupportedExceptionProto()
    }
    set {result = .deviceNotSupportedExceptionProto(newValue)}
  }

  var healthConnectNotInstalledExceptionProto: HealthConnectNotInstalledExceptionProto {
    get {
      if case .healthConnectNotInstalledExceptionProto(let v)? = result {return v}
      return HealthConnectNotInstalledExceptionProto()
    }
    set {result = .healthConnectNotInstalledExceptionProto(newValue)}
  }

  var httpRequestExceptionProto: HttpRequestExceptionProto {
    get {
      if case .httpRequestExceptionProto(let v)? = result {return v}
      return HttpRequestExceptionProto()
    }
    set {result = .httpRequestExceptionProto(newValue)}
  }

  var missingConfigurationExceptionProto: MissingConfigurationExceptionProto {
    get {
      if case .missingConfigurationExceptionProto(let v)? = result {return v}
      return MissingConfigurationExceptionProto()
    }
    set {result = .missingConfigurationExceptionProto(newValue)}
  }

  var missingPermissionsExceptionProto: MissingPermissionsExceptionProto {
    get {
      if case .missingPermissionsExceptionProto(let v)? = result {return v}
      return MissingPermissionsExceptionProto()
    }
    set {result = .missingPermissionsExceptionProto(newValue)}
  }

  var requestQuotaExceededExceptionProto: RequestQuotaExceededExceptionProto {
    get {
      if case .requestQuotaExceededExceptionProto(let v)? = result {return v}
      return RequestQuotaExceededExceptionProto()
    }
    set {result = .requestQuotaExceededExceptionProto(newValue)}
  }

  var sdkNotInitializedExceptionProto: SDKNotInitializedExceptionProto {
    get {
      if case .sdkNotInitializedExceptionProto(let v)? = result {return v}
      return SDKNotInitializedExceptionProto()
    }
    set {result = .sdkNotInitializedExceptionProto(newValue)}
  }

  var timeoutExceptionProto: TimeoutExceptionProto {
    get {
      if case .timeoutExceptionProto(let v)? = result {return v}
      return TimeoutExceptionProto()
    }
    set {result = .timeoutExceptionProto(newValue)}
  }

  var userNotInitializedExceptionProto: UserNotInitializedExceptionProto {
    get {
      if case .userNotInitializedExceptionProto(let v)? = result {return v}
      return UserNotInitializedExceptionProto()
    }
    set {result = .userNotInitializedExceptionProto(newValue)}
  }

  var genericExceptionProto: GenericExceptionProto {
    get {
      if case .genericExceptionProto(let v)? = result {return v}
      return GenericExceptionProto()
    }
    set {result = .genericExceptionProto(newValue)}
  }

  var missingAndroidPermissionsExceptionProto: MissingAndroidPermissionsExceptionProto {
    get {
      if case .missingAndroidPermissionsExceptionProto(let v)? = result {return v}
      return MissingAndroidPermissionsExceptionProto()
    }
    set {result = .missingAndroidPermissionsExceptionProto(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Result: Equatable {
    case success(Bool)
    case deviceNotSupportedExceptionProto(DeviceNotSupportedExceptionProto)
    case healthConnectNotInstalledExceptionProto(HealthConnectNotInstalledExceptionProto)
    case httpRequestExceptionProto(HttpRequestExceptionProto)
    case missingConfigurationExceptionProto(MissingConfigurationExceptionProto)
    case missingPermissionsExceptionProto(MissingPermissionsExceptionProto)
    case requestQuotaExceededExceptionProto(RequestQuotaExceededExceptionProto)
    case sdkNotInitializedExceptionProto(SDKNotInitializedExceptionProto)
    case timeoutExceptionProto(TimeoutExceptionProto)
    case userNotInitializedExceptionProto(UserNotInitializedExceptionProto)
    case genericExceptionProto(GenericExceptionProto)
    case missingAndroidPermissionsExceptionProto(MissingAndroidPermissionsExceptionProto)

  #if !swift(>=4.1)
    static func ==(lhs: ResultBooleanProto.OneOf_Result, rhs: ResultBooleanProto.OneOf_Result) -> Bool {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch (lhs, rhs) {
      case (.success, .success): return {
        guard case .success(let l) = lhs, case .success(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.deviceNotSupportedExceptionProto, .deviceNotSupportedExceptionProto): return {
        guard case .deviceNotSupportedExceptionProto(let l) = lhs, case .deviceNotSupportedExceptionProto(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.healthConnectNotInstalledExceptionProto, .healthConnectNotInstalledExceptionProto): return {
        guard case .healthConnectNotInstalledExceptionProto(let l) = lhs, case .healthConnectNotInstalledExceptionProto(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.httpRequestExceptionProto, .httpRequestExceptionProto): return {
        guard case .httpRequestExceptionProto(let l) = lhs, case .httpRequestExceptionProto(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.missingConfigurationExceptionProto, .missingConfigurationExceptionProto): return {
        guard case .missingConfigurationExceptionProto(let l) = lhs, case .missingConfigurationExceptionProto(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.missingPermissionsExceptionProto, .missingPermissionsExceptionProto): return {
        guard case .missingPermissionsExceptionProto(let l) = lhs, case .missingPermissionsExceptionProto(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.requestQuotaExceededExceptionProto, .requestQuotaExceededExceptionProto): return {
        guard case .requestQuotaExceededExceptionProto(let l) = lhs, case .requestQuotaExceededExceptionProto(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.sdkNotInitializedExceptionProto, .sdkNotInitializedExceptionProto): return {
        guard case .sdkNotInitializedExceptionProto(let l) = lhs, case .sdkNotInitializedExceptionProto(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.timeoutExceptionProto, .timeoutExceptionProto): return {
        guard case .timeoutExceptionProto(let l) = lhs, case .timeoutExceptionProto(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.userNotInitializedExceptionProto, .userNotInitializedExceptionProto): return {
        guard case .userNotInitializedExceptionProto(let l) = lhs, case .userNotInitializedExceptionProto(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.genericExceptionProto, .genericExceptionProto): return {
        guard case .genericExceptionProto(let l) = lhs, case .genericExceptionProto(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      case (.missingAndroidPermissionsExceptionProto, .missingAndroidPermissionsExceptionProto): return {
        guard case .missingAndroidPermissionsExceptionProto(let l) = lhs, case .missingAndroidPermissionsExceptionProto(let r) = rhs else { preconditionFailure() }
        return l == r
      }()
      default: return false
      }
    }
  #endif
  }

  init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension HealthPermissionProto: @unchecked Sendable {}
extension AvailabilityStatusProto: @unchecked Sendable {}
extension DeviceNotSupportedExceptionProto: @unchecked Sendable {}
extension HealthConnectNotInstalledExceptionProto: @unchecked Sendable {}
extension HttpRequestExceptionProto: @unchecked Sendable {}
extension MissingConfigurationExceptionProto: @unchecked Sendable {}
extension MissingPermissionsExceptionProto: @unchecked Sendable {}
extension RequestQuotaExceededExceptionProto: @unchecked Sendable {}
extension SDKNotInitializedExceptionProto: @unchecked Sendable {}
extension TimeoutExceptionProto: @unchecked Sendable {}
extension UserNotInitializedExceptionProto: @unchecked Sendable {}
extension GenericExceptionProto: @unchecked Sendable {}
extension MissingAndroidPermissionsExceptionProto: @unchecked Sendable {}
extension ResultBooleanProto: @unchecked Sendable {}
extension ResultBooleanProto.OneOf_Result: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension HealthPermissionProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "SLEEP"),
    1: .same(proto: "PHYSICAL"),
    2: .same(proto: "BODY"),
    3: .same(proto: "ALL"),
  ]
}

extension AvailabilityStatusProto: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "INSTALLED"),
    1: .same(proto: "NOT_INSTALLED"),
    2: .same(proto: "NOT_SUPPORTED"),
  ]
}

extension DeviceNotSupportedExceptionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "DeviceNotSupportedExceptionProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: DeviceNotSupportedExceptionProto, rhs: DeviceNotSupportedExceptionProto) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HealthConnectNotInstalledExceptionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HealthConnectNotInstalledExceptionProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HealthConnectNotInstalledExceptionProto, rhs: HealthConnectNotInstalledExceptionProto) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension HttpRequestExceptionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "HttpRequestExceptionProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
    2: .same(proto: "code"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self.code) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    if self.code != 0 {
      try visitor.visitSingularUInt32Field(value: self.code, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: HttpRequestExceptionProto, rhs: HttpRequestExceptionProto) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.code != rhs.code {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MissingConfigurationExceptionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MissingConfigurationExceptionProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MissingConfigurationExceptionProto, rhs: MissingConfigurationExceptionProto) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MissingPermissionsExceptionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MissingPermissionsExceptionProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MissingPermissionsExceptionProto, rhs: MissingPermissionsExceptionProto) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension RequestQuotaExceededExceptionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "RequestQuotaExceededExceptionProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: RequestQuotaExceededExceptionProto, rhs: RequestQuotaExceededExceptionProto) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SDKNotInitializedExceptionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "SDKNotInitializedExceptionProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: SDKNotInitializedExceptionProto, rhs: SDKNotInitializedExceptionProto) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension TimeoutExceptionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "TimeoutExceptionProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: TimeoutExceptionProto, rhs: TimeoutExceptionProto) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UserNotInitializedExceptionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "UserNotInitializedExceptionProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: UserNotInitializedExceptionProto, rhs: UserNotInitializedExceptionProto) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GenericExceptionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "GenericExceptionProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: GenericExceptionProto, rhs: GenericExceptionProto) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension MissingAndroidPermissionsExceptionProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "MissingAndroidPermissionsExceptionProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "message"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.message) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.message.isEmpty {
      try visitor.visitSingularStringField(value: self.message, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: MissingAndroidPermissionsExceptionProto, rhs: MissingAndroidPermissionsExceptionProto) -> Bool {
    if lhs.message != rhs.message {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ResultBooleanProto: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = "ResultBooleanProto"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success"),
    2: .same(proto: "deviceNotSupportedExceptionProto"),
    3: .same(proto: "healthConnectNotInstalledExceptionProto"),
    4: .same(proto: "httpRequestExceptionProto"),
    5: .same(proto: "missingConfigurationExceptionProto"),
    6: .same(proto: "missingPermissionsExceptionProto"),
    7: .same(proto: "requestQuotaExceededExceptionProto"),
    8: .same(proto: "sdkNotInitializedExceptionProto"),
    9: .same(proto: "timeoutExceptionProto"),
    10: .same(proto: "userNotInitializedExceptionProto"),
    11: .same(proto: "genericExceptionProto"),
    12: .same(proto: "missingAndroidPermissionsExceptionProto"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.result != nil {try decoder.handleConflictingOneOf()}
          self.result = .success(v)
        }
      }()
      case 2: try {
        var v: DeviceNotSupportedExceptionProto?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .deviceNotSupportedExceptionProto(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .deviceNotSupportedExceptionProto(v)
        }
      }()
      case 3: try {
        var v: HealthConnectNotInstalledExceptionProto?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .healthConnectNotInstalledExceptionProto(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .healthConnectNotInstalledExceptionProto(v)
        }
      }()
      case 4: try {
        var v: HttpRequestExceptionProto?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .httpRequestExceptionProto(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .httpRequestExceptionProto(v)
        }
      }()
      case 5: try {
        var v: MissingConfigurationExceptionProto?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .missingConfigurationExceptionProto(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .missingConfigurationExceptionProto(v)
        }
      }()
      case 6: try {
        var v: MissingPermissionsExceptionProto?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .missingPermissionsExceptionProto(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .missingPermissionsExceptionProto(v)
        }
      }()
      case 7: try {
        var v: RequestQuotaExceededExceptionProto?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .requestQuotaExceededExceptionProto(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .requestQuotaExceededExceptionProto(v)
        }
      }()
      case 8: try {
        var v: SDKNotInitializedExceptionProto?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .sdkNotInitializedExceptionProto(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .sdkNotInitializedExceptionProto(v)
        }
      }()
      case 9: try {
        var v: TimeoutExceptionProto?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .timeoutExceptionProto(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .timeoutExceptionProto(v)
        }
      }()
      case 10: try {
        var v: UserNotInitializedExceptionProto?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .userNotInitializedExceptionProto(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .userNotInitializedExceptionProto(v)
        }
      }()
      case 11: try {
        var v: GenericExceptionProto?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .genericExceptionProto(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .genericExceptionProto(v)
        }
      }()
      case 12: try {
        var v: MissingAndroidPermissionsExceptionProto?
        var hadOneofValue = false
        if let current = self.result {
          hadOneofValue = true
          if case .missingAndroidPermissionsExceptionProto(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.result = .missingAndroidPermissionsExceptionProto(v)
        }
      }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.result {
    case .success?: try {
      guard case .success(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 1)
    }()
    case .deviceNotSupportedExceptionProto?: try {
      guard case .deviceNotSupportedExceptionProto(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    }()
    case .healthConnectNotInstalledExceptionProto?: try {
      guard case .healthConnectNotInstalledExceptionProto(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    }()
    case .httpRequestExceptionProto?: try {
      guard case .httpRequestExceptionProto(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    }()
    case .missingConfigurationExceptionProto?: try {
      guard case .missingConfigurationExceptionProto(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    }()
    case .missingPermissionsExceptionProto?: try {
      guard case .missingPermissionsExceptionProto(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    }()
    case .requestQuotaExceededExceptionProto?: try {
      guard case .requestQuotaExceededExceptionProto(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    }()
    case .sdkNotInitializedExceptionProto?: try {
      guard case .sdkNotInitializedExceptionProto(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    }()
    case .timeoutExceptionProto?: try {
      guard case .timeoutExceptionProto(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    }()
    case .userNotInitializedExceptionProto?: try {
      guard case .userNotInitializedExceptionProto(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 10)
    }()
    case .genericExceptionProto?: try {
      guard case .genericExceptionProto(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 11)
    }()
    case .missingAndroidPermissionsExceptionProto?: try {
      guard case .missingAndroidPermissionsExceptionProto(let v)? = self.result else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ResultBooleanProto, rhs: ResultBooleanProto) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
